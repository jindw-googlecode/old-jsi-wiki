#labels Featured
== 等闲识得东风面 万紫千红总是春—— JSI初印象 ==
 * 分包组织
     * JSI的脚本组织借鉴了Java分包的形式。

 * 装载单元
     * JSI装载单元体现的是模块隔离的思想，不同的装载单元是一个个孤立的编程单元。而不同的装载单元之间的联系的建立需要显示的依赖申明。

 * 按需导入
      * JSI引入脚本，使用$import函数，他将自动导入指定元素及其依赖（依赖外界不可见，不暴露）。
      * JSI同时支持：同步装载模式、异步装载模式、延迟装载模式（无阻塞的伪同步）。

 * 按需导出
      * JSI作为一个无侵入的框架，那么你可以随时将类库从框架中导出成普通脚本，完全脱离框架。


== 上善若水 水利万物而不争——风格与特征 ==
 * 无侵入
      * 所谓无侵入，就是说，在JSI管理的脚本中，无需增加JSI特有的元素；脚本还是简单的脚本。
      * 不加入特殊语法，被管理的脚本无框架依赖。
      * JSI集成第三方脚本时，一般也无需改动原来的脚本。

 * 自由简单
      * 用户可以极大限度的延续自己的编程习惯。
      * JSI对被管理的脚本，没有繁琐的条条框框，脚本还是以前简单的脚本。
      * JSI引入了包的概念，但与YUI之类类库的包不同。他无需显示申明，我们通过文件位置直接映射到相应包路径—— 约定优于配置。




== 满堂花醉三千客 一剑霜寒十四州——基本功能 ==
 * 管理依赖
      * 避免依赖的暴露、扩散，提高类库的易用性

 * 隔离冲突
      * JSI中，每个脚本都有单独的执行上下文，不必担心不同脚本的命名冲突。
      * 在JSI的保护下，我们你可以自由大胆的使用全局变量。

 * 按需导入/合并导出
      * 使用$import函数，JSI将自动导入您指定元素及其依赖（依赖外界不可见）。
      * JSI管理的脚本，可以随时导出成普通脚本，完全脱离框架依赖。 让你的脚本以最快的速度运行，。
      * 你既可以在开发时享受细分模块带来的调试的便捷。又能避免上线后零散文件，及脚本管理逻辑对系统性能的影响，

== 落霞与孤鹜齐飞 秋水共长天一色—— JSI编程元素 ==
 * 依赖管理及模块隔离。
      * 这是JSI内核最基本的功能。

 * 开发期与编译期的脚本管理。
      * 在开发期间，我们可以使用脚本托管方式工作，方便于部署调试及源代码的管理。
      * 而运行期间，如有需要，我们也可以将托管脚本导出，最大限度的提高运行性能，这个过程可以是自动的。

 * 友好调试支持。
      * 对于动态加载的脚本的调试，一直是个麻烦的问题，对此JSI有非常有效的解决办法。

 * 可选辅助开发环境。
      * JSIDoc是一个实时的API文档解析工具。
      * 自动装载测试，可自动检测全部装在期错误。
      * 前端模版开发测试及编译环境。

== 没有规矩 无以成方圆——管理好自己的脚本 ==
 * 作为类库/模块开发人员，应该管理好自己的脚本，简化模块的接口，封装内部关系；要求用户知道的太多，不是一个好的风格。
 * 通过分包组织，方便于多人合作开发，以及对总体架构的把握。
 * 有了准确的包描述信息，有利于开发环境及时准确的发现更多的潜在问题。
 * 通过脚本管理，有利于我们处理好自己脚本之间的依赖关系；借助实时文档工具，随时回顾程序结构，作出相应调整。
 * 有了JSI的依赖管理与冲突隔离的保障，我们可以更放心的在自己的范围内做好自己的工作。
 * 通过JSI的自动装载测试，以及配套开发环境，我们可以提前发现更多的低级问题。


== 海纳百川 有容乃大——集成第三方库 ==
 * Java的成功，离不开它那个庞大的类库，不单是sun的类库，很多细节的实现都取自第三方（如xml解析采用Apache的实现）。
 * 我们在前端脚本开发过程中，也期望能够博采众长。
 * 在JSI的帮助下，我们可以做到基本不修改源代码的情况下，将第三方库纳入JSI体系之中。

== 壁立千仞 无欲则刚——控制依赖 ==
 * Java可以随意的使用第三方类库，可是JavaScript却没那么幸运，随着类库的丰富，烦杂的依赖关系和可能的命名冲突将使得类库的发展越来越困难。程序的易用性也将大打折扣。
 * 命名冲突的危险无形的增加你大脑的负担；随着使用的类库的增加，暴露的依赖也将随之增加，这是复杂度陡增的极大祸根，将使得系统越来越复杂，越来越难以控制。潜在的问题越来越多，防不胜防。
 * JSI的出现，可以解决上述问题，我们建议类库的开发者将自己类库的依赖终结在自己手中，避免依赖扩散，以提高类库的易用性。

== 百花齐放 日月同辉——隔离冲突 ==
 * JSI针对每一个装载的脚本都有完全独立的执行上下文。他在集成第三方库的同时，可以轻松的隔离各个脚本的执行上下文，消除可能的命名冲突危险。
 * 如， Scriptaculous所依赖的Prototype库与jQuery存在冲突。所以同时使用比较困难。而通过JSI，我们可以漂亮的解决此类问题。

== 关山难越 谁悲失路之人——重视阻塞问题 ==
 * 何为阻塞？浏览器使用XMLHttpRequest同步获取资源时将导致浏览器停止用户事件响应、停止页面重画操作。这种现象号称假死，用户体验极差。
 * 目前为止，所有宣称可以按需装载的框架都有这个毛病。所以，大家都不敢使用真正的安需装载，而解决办法，大都采用一起打包的方式，把所有可能使用到的脚本都打包在一个文件中。而所谓的按需装载只是一个口号罢了。
 * JSI2开始着手解决这个问题，有两种解决方案：异步导入、延迟同步导入。

== 山重水复疑无路 柳暗花明又一村——跳出eval泥潭 ==
 * JSI2.5之后，对于调试提供了良好支持。在调试模式下，可以通过延迟装载，避开eval代码导致的调试泥潭。
 * 在JSI的帮助下，你可以把源码轻松的组织在大小适当的文件中。
 * 装载期间，我们可以使用延迟装载，而避免直接的eval代码，这样，你还可以轻松的在一些调试工具中设置断点，单步调试等等。

== 云想衣裳花想容 春风拂槛露华浓—— JSI装饰引擎 ==
 * 用于装饰朴素html元素的框架，使用简单的xml标记，标识其装饰行为，比如将一个普通的input装饰成一个日期输入控件，将一个html ul标记装饰成菜单或树，将一个textarea装饰成一个代码语法高亮显示区域，或一个wysiwyg html编辑器。
 * JSI启动后将自动检查decorator标记，构建层次结构，自动做相关类的寻找、导入和装饰操作；实现零脚本代码的web富客户端编程。
 * 注备：JSI2.5之后，我暂停了该功能以便集中精力完善内核（或许这章的标题因命名为“东风无力百花残”了，哈哈哈哈） 。

== 身无彩凤双飞翼 心有灵犀一点通——致初学者 ==
 * 简单与不简单
      * 了解 IOC 的概念和价值。
      * 如果还不能理解 IOC 的价值，你可能同样不能理解JSI的价值。
 * 简单与不简单
      * JSI对外的接口是简单的，与同类框架比较，暴露的API确实最少。
      * JSI是目前唯一的一个可以支持异步导入和非阻塞延迟导入的成熟的脚本管理框架。
      * JSI的脚本依赖管理功能相对完善，实现了装载依赖的前后区分。
      * 综上，看似简单的JSI却有着强大和复杂的一面。
 * 关于源码
      * JSI的原码相对复杂枯燥，而且出于性能，压缩等因素考虑，很多写法略显怪癖。
      * JSI 的API相对简单，你可以轻松的熟悉他们。
      * 如果有疑问，你也可以到论坛提出你的问题。
 * 不建议初级程序员去研究
      * JSI 目前的社群并不活跃，资料太少。
      * 我们暂时还不能提供丰富的实用类库。
      * 功能都要自行开发或者集成第三方。
 * 可以尝试揣摩API设计的理由。



== 蓬山此去无多路 青鸟殷勤为看探——社区&资源 ==
 * JSI 项目主页
      * http://www.jside.org/project/jsi

 * JSI 邮件列表
      * http://groups.google.com/group/jsier

 * JSI IM 群
      * MSN群：group167973@msnzone.cn
      * QQ群：23180506 