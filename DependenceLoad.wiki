#labels Phase-Design
=== 一个脚本及其依赖分类：===
 * *直接装载前依赖*
   当前脚本装载时，需要直接触发的引用。
 * _*直接装载后依赖*_
   当前脚本运行时，可能直接触发的引用
 * *装载前依赖*
   # *直接装载前依赖*的*直接装载前依赖*。
   # *装载前依赖*的*直接装载前依赖*。
 * _*装载后依赖*_
   不属于当前角本的*装载前依赖*
   且：
     # *装载前依赖*的_*装载后依赖*_。
     # _*直接装载后依赖*_的_*装载后依赖*_。
     # _*直接装载后依赖*_的*装载前依赖*。
   
=== 间接依赖运算模型：===
  * *装载前依赖*的*装载前依赖* ==> *装载前依赖* 
  * *装载前依赖*的_*装载后依赖*_ ==> _*装载后依赖*_
  * _*装载后依赖*_的*装载前依赖* ==> _*装载后依赖*_
  * _*装载后依赖*_的_*装载后依赖*_ ==> _*装载后依赖*_

=== 循环依赖的存在方式：===
  ==== 非法存在方式：====
   * *装载前依赖*中存在*当前脚本*：
     依赖异常，两者相互要求对方先于自己装载，这是自相矛盾的逻辑。
  ==== 依赖可能存在的方式：====
   * _*装载后依赖*_中存在*当前脚本*：
     允许的情况；如果循环依赖中一方是*装载前依赖*，可能会出现如下问题:
     某些脚本的某些装载前依赖的装载后依赖未装载，这是，装载前依赖虽然可以安全引用，但是，调用可能失败。
     所以，一旦你的脚本中存在有一方为*装载前依赖*的循环依赖，那么你的脚本最好不要出现装载期间直接调用*装载前依赖*的函数的代码。

=== 避免依赖问题的建议：===
  我们需要确保*装载前依赖*正确装载，就可以确保装载按照期待方式处理。
  * *装载前依赖*中
    不允许有当前脚本。即上述非法循环依赖
  * *装载前依赖*的_*装载后依赖*_中若存在当前脚本
    在装载过程中避免调用用*装载前依赖*的函数，或者访问*装载前依赖*对象的属性